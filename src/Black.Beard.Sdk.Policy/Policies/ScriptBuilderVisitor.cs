using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using Bb.Analysis.DiagTraces;
using Bb.Policies.Asts;
using Bb.Policies.Parser;
using System.Globalization;
using System.Text;

#pragma warning disable CS3001
#pragma warning disable CS3003

namespace Bb.Policies
{


    /// <summary>
    /// Generate tree of script from a Policy script text
    /// </summary>
    /// <remarks>
    /// ScriptBuilderVisitor implements the visitor pattern to traverse the parse tree 
    /// generated by ANTLR and build a policy AST from it.
    /// </remarks>
    public class ScriptBuilderVisitor : PolicyParserBaseVisitor<object>
    {

        /// <summary>
        /// Initializes static members of the <see cref="ScriptBuilderVisitor"/> class.
        /// </summary>
        /// <remarks>
        /// This static constructor initializes any shared resources or configurations needed by all instances
        /// of the ScriptBuilderVisitor class.
        /// </remarks>
        static ScriptBuilderVisitor()
        {

        }

        /// <summary>
        /// Create a new instance of <see cref="ScriptBuilderVisitor"/> with a container and rule action.
        /// </summary>
        /// <param name="parser">The policy parser that generated the parse tree. Must not be null.</param>
        /// <param name="diagnostics">Container for diagnostic messages generated during parsing. Must not be null.</param>
        /// <param name="container">The container to which parsed policies will be added. Can be null.</param>
        /// <param name="action">Action to execute on each parsed policy rule. Can be null.</param>
        /// <param name="path">The file path of the policy script being parsed. Can be null or empty.</param>
        /// <remarks>
        /// This constructor creates a visitor that will add parsed policies to the specified container
        /// and execute the specified action on each policy rule. It delegates to the basic constructor
        /// for initialization of parser, diagnostics, and path.
        /// </remarks>
        /// <exception cref="System.ArgumentNullException">Thrown when parser or diagnostics is null.</exception>
        /// <example>
        /// <code lang="C#">
        /// var lexer = new PolicyLexer(new AntlrInputStream(policyText));
        /// var tokenStream = new CommonTokenStream(lexer);
        /// var parser = new PolicyParser(tokenStream);
        /// var diagnostics = new ScriptDiagnostics();
        /// var container = new PolicyContainer();
        /// 
        /// var visitor = new ScriptBuilderVisitor(parser, diagnostics, container, 
        ///     rule => Console.WriteLine($"Parsed rule: {rule.Name}"), 
        ///     "policy.txt");
        /// 
        /// var result = visitor.Visit(parser.script());
        /// </code>
        /// </example>
        public ScriptBuilderVisitor(PolicyParser parser, ScriptDiagnostics diagnostics, PolicyContainer container, Action<PolicyRule> action, string path) 
            : this(parser, diagnostics, path)
        {
            _container = container;
            _action = action;
        }


        /// <summary>
        /// Create a new instance of <see cref="ScriptBuilderVisitor"/> with basic parameters.
        /// </summary>
        /// <param name="parser">The policy parser that generated the parse tree. Must not be null.</param>
        /// <param name="diagnostics">Container for diagnostic messages generated during parsing. Must not be null.</param>
        /// <param name="path">The file path of the policy script being parsed. Can be null or empty.</param>
        /// <remarks>
        /// This constructor initializes the visitor with the specified parser, diagnostics container,
        /// and script path. It sets the culture to InvariantCulture and resolves the script directory path.
        /// </remarks>
        /// <exception cref="System.ArgumentNullException">Thrown when parser or diagnostics is null.</exception>
        /// <example>
        /// <code lang="C#">
        /// var lexer = new PolicyLexer(new AntlrInputStream(policyText));
        /// var tokenStream = new CommonTokenStream(lexer);
        /// var parser = new PolicyParser(tokenStream);
        /// var diagnostics = new ScriptDiagnostics();
        /// 
        /// var visitor = new ScriptBuilderVisitor(parser, diagnostics, "policy.txt");
        /// var result = visitor.Visit(parser.script());
        /// </code>
        /// </example>
        public ScriptBuilderVisitor(PolicyParser parser, ScriptDiagnostics diagnostics, string path)
        {
            _currentCulture = CultureInfo.InvariantCulture;
            _parser = parser;
            _diagnostics = diagnostics;
            _scriptPath = path;

            if (!string.IsNullOrEmpty(path))
            {
                var dir = new FileInfo(path).Directory;
                if (dir != null)
                    _scriptPathDirectory = dir.FullName;
            }

            if (string.IsNullOrEmpty(_scriptPathDirectory))
                _scriptPathDirectory = AppDomain.CurrentDomain.BaseDirectory;

        }

        /// <summary>
        /// Parse tree produced by <see cref="PolicyParser.script"/>.
        /// </summary>
        /// <param name="context">The parse tree context for the script. Must not be null.</param>
        /// <returns>A PolicyContainer containing all parsed policy elements.</returns>
        /// <remarks>
        /// This method visits the script context and builds a complete policy container from all the
        /// policy elements defined in the script. It checks for duplicate names and reports errors.
        /// </remarks>
        /// <exception cref="System.ArgumentNullException">Thrown when context is null.</exception>
        /// <example>
        /// <code lang="C#">
        /// var visitor = new ScriptBuilderVisitor(parser, diagnostics, "policy.txt");
        /// var container = visitor.VisitScript(parser.script());
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyContainer"/> containing all policy elements from the script.
        /// </returns>
        public override object VisitScript([NotNull] PolicyParser.ScriptContext context)
        {

            _initialSource = new StringBuilder(context.Start.InputStream.ToString());

            var pair = context.pair();

            if (_container == null)
                _container = new PolicyContainer() { Diagnostics = _diagnostics };

            foreach (var item in pair)
            {
                var o = (Policy)item.Accept(this);
                if (o != null)
                {

                    if (_action != null && o is PolicyRule r1)
                        _action(r1);

                    if (!_container.Add(o))
                    {

                        string name = o.ToString();

                        if (o is PolicyRule r)
                            name = "policy " + r.Name;

                        else if (o is PolicyVariable s)
                            name = "alias " + s.Name;

                        this.AddError(o.Location, name, "duplicated name", _scriptPath);

                    }
                }
            }

            return _container;

        }

        /// <summary>
        /// Visits a category context and extracts the category identifier.
        /// </summary>
        /// <param name="context">The context for a category in the policy script. Must not be null.</param>
        /// <returns>The text of the category identifier, or null if not found.</returns>
        /// <remarks>
        /// This method extracts the text of a category identifier from the parse tree.
        /// Categories are used for grouping and filtering policy rules.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var categoryContext = parser.category();
        /// var categoryName = (string)visitor.VisitCategory(categoryContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="System.String"/> containing the category identifier, or null if not found.
        /// </returns>
        public override object VisitCategory([NotNull] PolicyParser.CategoryContext context)
        {

            var id = context.ID();
            if (id != null)
                return id.GetText();

            return null;
        }

        /// <summary>
        /// Visits a policy identifier context and extracts the policy name.
        /// </summary>
        /// <param name="context">The context for a policy identifier. Must not be null.</param>
        /// <returns>The text of the policy identifier, or null if not found.</returns>
        /// <remarks>
        /// This method extracts the name of a policy rule from the parse tree.
        /// It handles both regular identifiers and quoted identifiers.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var policyIdContext = parser.policy_id();
        /// var policyName = (string)visitor.VisitPolicy_id(policyIdContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="System.String"/> containing the policy identifier, or null if not found.
        /// </returns>
        public override object VisitPolicy_id([NotNull] PolicyParser.Policy_idContext context)
        {

            var id = context.ID();
            if (id != null)
                return id.GetText();

            id = context.IDQUOTED();
            if (id != null)
                return id.GetText().Trim('\'');

            return null;
        }

        /// <summary>
        /// Visits an alias identifier context and extracts the alias name.
        /// </summary>
        /// <param name="context">The context for an alias identifier. Must not be null.</param>
        /// <returns>The text of the alias identifier, or null if not found.</returns>
        /// <remarks>
        /// This method extracts the name of an alias (variable) from the parse tree.
        /// It handles both regular identifiers and quoted identifiers.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var aliasIdContext = parser.alias_id();
        /// var aliasName = (string)visitor.VisitAlias_id(aliasIdContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="System.String"/> containing the alias identifier, or null if not found.
        /// </returns>
        public override object VisitAlias_id([NotNull] PolicyParser.Alias_idContext context)
        {
            var id = context.ID();
            if (id != null)
                return id.GetText();

            id = context.IDQUOTED();
            if (id != null)
                return id.GetText().Trim('\'');

            return null;
        }

        /// <summary>
        /// Visits a policy reference context and extracts the referenced policy name.
        /// </summary>
        /// <param name="context">The context for a policy reference. Must not be null.</param>
        /// <returns>The text of the referenced policy identifier, or null if not found.</returns>
        /// <remarks>
        /// This method extracts the name of a referenced policy from the parse tree.
        /// It handles both regular identifiers and quoted identifiers.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var policyRefContext = parser.policy_ref();
        /// var referencedPolicy = (string)visitor.VisitPolicy_ref(policyRefContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="System.String"/> containing the referenced policy identifier, or null if not found.
        /// </returns>
        public override object VisitPolicy_ref([NotNull] PolicyParser.Policy_refContext context)
        {
            var id = context.ID();
            if (id != null)
                return id.GetText();

            id = context.IDQUOTED();
            if (id != null)
                return id.GetText().Trim('\'');

            return null;
        }

        /// <summary>
        /// Visits a string context and extracts the string value.
        /// </summary>
        /// <param name="context">The context for a string in the policy script. Must not be null.</param>
        /// <returns>The string value with quotes removed, or an empty string if not found.</returns>
        /// <remarks>
        /// This method extracts a string literal from the parse tree, removing the surrounding quotes.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var stringContext = parser.string();
        /// var stringValue = (string)visitor.VisitString(stringContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="System.String"/> containing the string value with quotes removed.
        /// </returns>
        public override object VisitString([NotNull] PolicyParser.StringContext context)
        {

            ITerminalNode str = context.STRING();
            if (str != null)
            {
                var txt = str.GetText()?.Trim() ?? string.Empty;
                return txt.Trim('"');
            }

            return string.Empty;

        }

        /// <summary>
        /// Visits a key reference context and creates a policy constant for the key.
        /// </summary>
        /// <param name="context">The context for a key reference. Must not be null.</param>
        /// <returns>A policy constant representing the key.</returns>
        /// <remarks>
        /// This method creates a policy constant from a key reference in the parse tree,
        /// handling both regular identifiers and quoted identifiers.
        /// </remarks>
        /// <exception cref="System.NotImplementedException">Thrown when the context contains an unsupported key reference format.</exception>
        /// <example>
        /// <code lang="C#">
        /// var keyRefContext = parser.key_ref();
        /// var keyConstant = (PolicyConstant)visitor.VisitKey_ref(keyRefContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyConstant"/> representing the key reference.
        /// </returns>
        public override object VisitKey_ref([NotNull] PolicyParser.Key_refContext context)
        {

            var id = context.ID();
            if (id != null)
                return new PolicyConstant(id.GetText(), ConstantType.Id) { Location = context.ToLocation() };

            var id2 = context.IDQUOTED();
            if (id2 != null)
                return new PolicyConstant(id2.GetText().Trim('\''), ConstantType.QuotedId) { Location = context.ToLocation() };

            throw new NotImplementedException(context.GetText());

        }

        /// <summary>
        /// Visits a value reference context and creates a policy constant for the value.
        /// </summary>
        /// <param name="context">The context for a value reference. Must not be null.</param>
        /// <returns>A policy constant representing the value.</returns>
        /// <remarks>
        /// This method creates a policy constant from a value reference in the parse tree,
        /// handling strings, identifiers, quoted identifiers, and boolean values.
        /// </remarks>
        /// <exception cref="System.NotImplementedException">Thrown when the context contains an unsupported value reference format.</exception>
        /// <example>
        /// <code lang="C#">
        /// var valueRefContext = parser.value_ref();
        /// var valueConstant = (PolicyConstant)visitor.VisitValue_ref(valueRefContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyConstant"/> representing the value reference.
        /// </returns>
        public override object VisitValue_ref([NotNull] PolicyParser.Value_refContext context)
        {

            var str = context.@string();
            if (str != null)
                return new PolicyConstant((string)str.Accept(this), ConstantType.String) { Location = context.ToLocation() };

            var id = context.ID();
            if (id != null)
                return new PolicyConstant(id.GetText(), ConstantType.Id) { Location = context.ToLocation() };

            var id2 = context.IDQUOTED();
            if (id2 != null)
                return new PolicyConstant(id2.GetText().Trim('\''), ConstantType.QuotedId) { Location = context.ToLocation() };

            var boolean = context.boolean();
            if (boolean != null)
                return new PolicyConstant(boolean.GetText(), ConstantType.Boolean) { Location = context.ToLocation() };

            throw new NotImplementedException(context.GetText());

        }

        /// <summary>
        /// Visits a source context and extracts the source identifier.
        /// </summary>
        /// <param name="context">The context for a source reference. Must not be null.</param>
        /// <returns>The text of the source identifier, or null if not found.</returns>
        /// <remarks>
        /// This method extracts the identifier of a source reference from the parse tree,
        /// handling both regular identifiers and quoted identifiers.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var sourceContext = parser.source();
        /// var sourceName = (string)visitor.VisitSource(sourceContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="System.String"/> containing the source identifier, or null if not found.
        /// </returns>
        public override object VisitSource([NotNull] PolicyParser.SourceContext context)
        {

            var id = context.ID();
            if (id != null)
                return id.GetText();

            id = context.IDQUOTED();
            if (id != null)
                return id.GetText().Trim('\'');

            return null;

        }

        /// <summary>
        /// Visits an alias definition and creates a policy variable.
        /// </summary>
        /// <param name="context">The context for an alias definition. Must not be null.</param>
        /// <returns>A policy variable representing the alias, or null if the alias_id is not found.</returns>
        /// <remarks>
        /// This method creates a policy variable from an alias definition in the parse tree.
        /// It extracts the alias name and value, and sets the origin to the script path.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var aliasContext = parser.pair_alias();
        /// var variable = (PolicyVariable)visitor.VisitPair_alias(aliasContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyVariable"/> representing the alias, or null if the alias_id is not found.
        /// </returns>
        public override object VisitPair_alias([NotNull] PolicyParser.Pair_aliasContext context)
        {

            var alias_id = context.alias_id();
            if (alias_id == null)
                return null;

            var _id = (string)context.alias_id().Accept(this);
            var str = context.@string();
            if (str != null)
            {
                var s = (string)str.Accept(this);
                return new PolicyVariable(_id)
                {
                    Origin = _scriptPath,
                    Value = new PolicyConstant(s, ConstantType.String)
                    {
                        Location = str.ToLocation()
                    },
                    Location = context.ToLocation()
                };

            }

            return null;
        }

        /// <summary>
        /// Visits a policy definition and creates a policy rule.
        /// </summary>
        /// <param name="context">The context for a policy definition. Must not be null.</param>
        /// <returns>A policy rule representing the policy, or the result of the base visitor if the structure is invalid.</returns>
        /// <remarks>
        /// This method creates a policy rule from a policy definition in the parse tree.
        /// It extracts the policy name, inheritance information, categories, and the policy expression.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var policyContext = parser.pair_policy();
        /// var rule = (PolicyRule)visitor.VisitPair_policy(policyContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyRule"/> representing the policy, or the result of the base visitor if the structure is invalid.
        /// </returns>
        public override object VisitPair_policy([NotNull] PolicyParser.Pair_policyContext context)
        {

            var policy_id = context.policy_id();
            if (policy_id == null)
                return null;

            string inheritFrom = string.Empty;
            var inherit = context.inherit();
            if (inherit != null)
                inheritFrom = (string)inherit.policy_ref().Accept(this);


            var expr = context.expression();
            if (expr != null)
            {

                var _id = (string)policy_id.Accept(this);

                if (inheritFrom == _id)
                    AddError(inherit?.ToLocation() ?? TextLocation.Empty, inheritFrom, "recursive rule detected");


                var e = expr.Accept(this);

                var result = new PolicyRule(_id)
                {
                    Value = (Policy)e,
                    Location = context.ToLocation(),
                    InheritFrom = inheritFrom,
                    Origin = _scriptPath
                };

                var categories = context.categories();
                if (categories != null)
                {
                    var c = (List<string>)categories.Accept(this);
                    result.AddCategories(c);
                }

                return result;

            }

            return base.VisitPair_policy(context);
        }

        /// <summary>
        /// Visits a boolean operation expression and determines the operator type.
        /// </summary>
        /// <param name="context">The context for a boolean operation. Must not be null.</param>
        /// <returns>The policy operator enum value for the boolean operation.</returns>
        /// <remarks>
        /// This method determines the type of boolean operation (AND or OR) from the parse tree.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var operationContext = parser.operationBoolean();
        /// var operatorType = (PolicyOperator)visitor.VisitOperationBoolean(operationContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyOperator"/> enum value representing the boolean operation.
        /// </returns>
        public override object VisitOperationBoolean([NotNull] PolicyParser.OperationBooleanContext context)
        {

            if (context.AND() != null)
                return PolicyOperator.AndExclusive;

            if (context.OR() != null)
                return PolicyOperator.OrExclusive;

            throw new NotImplementedException(context.GetText());
        }

        /// <summary>
        /// Visits a contains operation expression and determines the operator type.
        /// </summary>
        /// <param name="context">The context for a contains operation. Must not be null.</param>
        /// <returns>The policy operator enum value for the contains operation.</returns>
        /// <remarks>
        /// This method determines the type of contains operation (IN, NOT IN, HAS, HAS NOT) from the parse tree.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var operationContext = parser.operationContains();
        /// var operatorType = (PolicyOperator)visitor.VisitOperationContains(operationContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyOperator"/> enum value representing the contains operation.
        /// </returns>
        public override object VisitOperationContains([NotNull] PolicyParser.OperationContainsContext context)
        {

            if (context.IN() != null)
                return PolicyOperator.In;

            if (context.NOT_IN() != null)
                return PolicyOperator.NotIn;

            if (context.HAS() != null)
                return PolicyOperator.Has;

            if (context.HAS_NOT() != null)
                return PolicyOperator.HasNot;

            throw new NotImplementedException(context.GetText());
        }

        /// <summary>
        /// Visits an equality operation expression and determines the operator type.
        /// </summary>
        /// <param name="context">The context for an equality operation. Must not be null.</param>
        /// <returns>The policy operator enum value for the equality operation.</returns>
        /// <remarks>
        /// This method determines the type of equality operation (EQUAL, INEQUAL) from the parse tree.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var operationContext = parser.operationEqual();
        /// var operatorType = (PolicyOperator)visitor.VisitOperationEqual(operationContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyOperator"/> enum value representing the equality operation.
        /// </returns>
        public override object VisitOperationEqual([NotNull] PolicyParser.OperationEqualContext context)
        {

            if (context.EQUAL() != null)
                return PolicyOperator.Equal;

            if (context.INEQUAL() != null)
                return PolicyOperator.NotEqual;

            throw new NotImplementedException(context.GetText());

        }

        /// <summary>
        /// Visits an expression context and creates a policy expression.
        /// </summary>
        /// <param name="context">The context for an expression. Must not be null.</param>
        /// <returns>A policy expression representing the parsed expression.</returns>
        /// <remarks>
        /// This method creates a policy expression from an expression context in the parse tree.
        /// It handles key references, value references, boolean operations, and sub-expressions.
        /// </remarks>
        /// <exception cref="System.NotImplementedException">Thrown when the context contains an unsupported expression format.</exception>
        /// <example>
        /// <code lang="C#">
        /// var expressionContext = parser.expression();
        /// var expression = (PolicyExpression)visitor.VisitExpression(expressionContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyExpression"/> representing the parsed expression.
        /// </returns>
        public override object VisitExpression([NotNull] PolicyParser.ExpressionContext context)
        {

            PolicyOperator _operator;
            var key_ref = context.key_ref();
            Policy left;

            if (key_ref != null)
            {
                string source = string.Empty;
                var l = context.source();
                if (l != null)
                    source = l.ID().GetText();

                left = (Policy)key_ref.Accept(this);
                left = new PolicyIdExpression((PolicyConstant)left) { Location = context.ToLocation(), Source = source };

                var plus = context.PLUS();
                if (plus != null)
                {
                    _operator = PolicyOperator.Required;
                    return new PolicyOperationUnary(left, _operator) { Location = context.ToLocation() };
                }

                var @operator = context.operationEqual();
                if (@operator == null)
                    return left;

                var value_ref = context.value_ref();
                if (value_ref != null)
                {
                    _operator = (PolicyOperator)@operator.Accept(this);
                    var right = (Policy)value_ref.Accept(this);
                    return new PolicyOperationBinary(left, _operator, right) { Location = context.ToLocation() };
                }
                

                _operator = (PolicyOperator)context.operationBoolean().Accept(this);
                return new PolicyOperationUnary(left, _operator) { Location = context.ToLocation() };

            }

            var e = context.expression();
            left = (Policy)e[0].Accept(this);

            if (context.PARENT_LEFT() != null)
                return new PolicySubExpression((PolicyExpression)left) { Location = context.ToLocation() };

            else if (context.NOT() != null)
            {
                _operator = PolicyOperator.Not;
                return new PolicyOperationUnary((PolicyExpression)left, _operator) { Location = context.ToLocation() };
            }

            var operaC = context.operationContains();
            if (operaC != null)
            {
                _operator = (PolicyOperator)operaC.Accept(this);
                var right = (Policy)context.array().Accept(this);
                return new PolicyOperationBinary(left, _operator, right) { Location = context.ToLocation() };
            }

            var o2 = context.operationBoolean();
            if (o2 != null)
            {
                _operator = (PolicyOperator)o2.Accept(this);
                var right = (Policy)e[1].Accept(this);
                return new PolicyOperationBinary(left, _operator, right) { Location = context.ToLocation() };
            }

            throw new NotImplementedException(context.GetText());

        }

        /// <summary>
        /// Visits an array context and creates a policy array.
        /// </summary>
        /// <param name="context">The context for an array. Must not be null.</param>
        /// <returns>A policy array representing the parsed array.</returns>
        /// <remarks>
        /// This method creates a policy array from an array context in the parse tree.
        /// It extracts the values and creates a list of policy constants.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var arrayContext = parser.array();
        /// var array = (PolicyArray)visitor.VisitArray(arrayContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="PolicyArray"/> representing the parsed array.
        /// </returns>
        public override object VisitArray([NotNull] PolicyParser.ArrayContext context)
        {

            var values = context.value_ref();
            if (values == null)
                return null;

            List<PolicyConstant> items = new List<PolicyConstant>(values.Length);
            foreach (var item in values)
            {
                var o = (PolicyConstant)item.Accept(this);
                items.Add(o);
            }

            return new PolicyArray(items) { Location = context.ToLocation() };
        }

        /// <summary>
        /// Visits a categories context and creates a list of category names.
        /// </summary>
        /// <param name="context">The context for categories. Must not be null.</param>
        /// <returns>A list of category names.</returns>
        /// <remarks>
        /// This method creates a list of category names from a categories context in the parse tree.
        /// It extracts the category identifiers and adds them to the list.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var categoriesContext = parser.categories();
        /// var categories = (List<string>)visitor.VisitCategories(categoriesContext);
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="List{String}"/> containing the category names.
        /// </returns>
        public override object VisitCategories([NotNull] PolicyParser.CategoriesContext context)
        {

            var values = context.category();
            if (values == null)
                return null;

            List<string> items = new List<string>(values.Length);
            foreach (var item in values)
            {
                var o = (string)item.Accept(this);
                if (!string.IsNullOrEmpty(o))
                    items.Add(o);
            }

            return items;

        }

        /// <summary>
        /// Evaluates errors in the parse tree and adds them to the diagnostics.
        /// </summary>
        /// <param name="item">The parse tree item to evaluate. Can be null.</param>
        /// <remarks>
        /// This method recursively evaluates errors in the parse tree and adds them to the diagnostics container.
        /// It handles error nodes and parser rule contexts with exceptions.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var tree = parser.script();
        /// visitor.EvaluateErrors(tree);
        /// </code>
        /// </example>
        public void EvaluateErrors(IParseTree item)
        {

            if (item != null)
            {

                if (item is ErrorNodeImpl e)
                    AddError(e);

                else if (item is ParserRuleContext r)
                {

                    if (r.exception != null)
                    {
                        AddError(r);
                    }

                }

                int c = item.ChildCount;
                for (int i = 0; i < c; i++)
                {
                    IParseTree child = item.GetChild(i);
                    EvaluateErrors(child);
                }

            }

        }

        /// <summary>
        /// Visits the parse tree and evaluates errors.
        /// </summary>
        /// <param name="tree">The parse tree to visit. Must not be null.</param>
        /// <returns>The result of visiting the parse tree.</returns>
        /// <remarks>
        /// This method visits the parse tree, evaluates errors, and then delegates to the base visitor.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var tree = parser.script();
        /// var result = visitor.Visit(tree);
        /// </code>
        /// </example>
        /// <returns>
        /// The result of visiting the parse tree.
        /// </returns>
        public override object Visit(IParseTree tree)
        {
            EvaluateErrors(tree);
            //if (this._diagnostics.Count > 0)
            //    LocalDebug.Stop();
            var result = base.Visit(tree);

            return result;

        }

        /// <summary>
        /// Gets the diagnostic messages generated during parsing.
        /// </summary>
        /// <remarks>
        /// This property provides access to any error, warning, or informational messages
        /// that were generated during the parsing process.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var visitor = new ScriptBuilderVisitor(parser, diagnostics, container, null, "policy.txt");
        /// visitor.Visit(parser.script());
        /// 
        /// foreach (var error in visitor.Errors)
        /// {
        ///     Console.WriteLine($"{error.Message} at {error.Location}");
        /// }
        /// </code>
        /// </example>
        /// <returns>
        /// A collection of <see cref="ScriptDiagnostic"/> objects representing the parsing errors.
        /// </returns>
        public IEnumerable<ScriptDiagnostic> Errors { get => _diagnostics; }

        /// <summary>
        /// Gets or sets the filename of the policy script being parsed.
        /// </summary>
        /// <remarks>
        /// This property stores the filename of the current policy script, which is used
        /// for error reporting and diagnostics.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var visitor = new ScriptBuilderVisitor(parser, diagnostics, container, null, null);
        /// visitor.Filename = "custom_policy.txt";
        /// </code>
        /// </example>
        public string? Filename { get; set; }

        /// <summary>
        /// Gets the culture used for parsing culture-specific values.
        /// </summary>
        /// <remarks>
        /// This property provides access to the culture settings used for parsing
        /// numbers, dates, and other culture-specific values in the policy script.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var visitor = new ScriptBuilderVisitor(parser, diagnostics, container, null, "policy.txt");
        /// CultureInfo culture = visitor.Culture;
        /// Console.WriteLine($"Parsing using culture: {culture.DisplayName}");
        /// </code>
        /// </example>
        /// <returns>
        /// A <see cref="System.Globalization.CultureInfo"/> object representing the current culture.
        /// </returns>
        public CultureInfo Culture { get => _currentCulture; }


        /// <summary>
        /// Adds an error to the diagnostics container.
        /// </summary>
        /// <param name="start">The location of the error. Can be null.</param>
        /// <param name="txt">The text associated with the error. Must not be null.</param>
        /// <param name="message">The error message. Must not be null.</param>
        /// <param name="path">The file path of the script. Can be null or empty.</param>
        /// <remarks>
        /// This method adds an error to the diagnostics container with the specified location, text, message, and path.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// visitor.AddError(new TextLocation(1, 1), "ErrorText", "ErrorMessage", "script.txt");
        /// </code>
        /// </example>
        void AddError(TextLocation? start, string txt, string message, string path)
        {
            if (start == null)
                start = TextLocation.Empty;
            _diagnostics.AddError(start.InDocument(path ?? Filename ?? string.Empty), txt, message);
        }

        /// <summary>
        /// Adds an error to the diagnostics container.
        /// </summary>
        /// <param name="start">The location of the error. Must not be null.</param>
        /// <param name="txt">The text associated with the error. Must not be null.</param>
        /// <param name="message">The error message. Must not be null.</param>
        /// <remarks>
        /// This method adds an error to the diagnostics container with the specified location, text, and message.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// visitor.AddError(new TextLocation(1, 1), "ErrorText", "ErrorMessage");
        /// </code>
        /// </example>
        void AddError(TextLocation start, string txt, string message)
        {
            _diagnostics.AddError(start.InDocument(Filename ?? string.Empty), txt, message);
        }

        /// <summary>
        /// Adds a warning to the diagnostics container.
        /// </summary>
        /// <param name="start">The location of the warning. Must not be null.</param>
        /// <param name="txt">The text associated with the warning. Must not be null.</param>
        /// <param name="message">The warning message. Must not be null.</param>
        /// <remarks>
        /// This method adds a warning to the diagnostics container with the specified location, text, and message.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// visitor.AddWarning(new TextLocation(1, 1), "WarningText", "WarningMessage");
        /// </code>
        /// </example>
        void AddWarning(TextLocation start, string txt, string message)
        {
            _diagnostics.AddWarning(start.InDocument(Filename ?? string.Empty), txt, message);
        }

        /// <summary>
        /// Adds a warning to the diagnostics container.
        /// </summary>
        /// <param name="start">The location of the warning. Must not be null.</param>
        /// <param name="txt">The text associated with the warning. Must not be null.</param>
        /// <param name="message">The warning message. Must not be null.</param>
        /// <param name="path">The file path of the script. Can be null or empty.</param>
        /// <remarks>
        /// This method adds a warning to the diagnostics container with the specified location, text, message, and path.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// visitor.AddWarning(new TextLocation(1, 1), "WarningText", "WarningMessage", "script.txt");
        /// </code>
        /// </example>
        void AddWarning(TextLocation start, string txt, string message, string path)
        {
            _diagnostics.AddWarning(start.InDocument(path ?? Filename ?? string.Empty), txt, message);
        }

        /// <summary>
        /// Adds an error to the diagnostics container from a parser rule context.
        /// </summary>
        /// <param name="r">The parser rule context containing the error. Must not be null.</param>
        /// <remarks>
        /// This method adds an error to the diagnostics container based on the information in the parser rule context.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var context = parser.rule();
        /// visitor.AddError(context);
        /// </code>
        /// </example>
        void AddError(ParserRuleContext r)
        {

            int stateId = r.invokingState;

            if (stateId == -1)
                stateId = r.exception.OffendingState;

            ATNState state = _parser.Atn.states[stateId];
            string o0 = _parser.RuleNames[state.ruleIndex];
            string o1 = _parser.RuleNames[r.RuleIndex];

            _diagnostics.AddError(r.Start.ToLocation(Filename ?? string.Empty), r.Start.Text, $"Failed to parse script. '{o0}' expect '{o1}'");

        }

        /// <summary>
        /// Adds an error to the diagnostics container from an error node.
        /// </summary>
        /// <param name="e">The error node containing the error. Must not be null.</param>
        /// <remarks>
        /// This method adds an error to the diagnostics container based on the information in the error node.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// var errorNode = parser.errorNode();
        /// visitor.AddError(errorNode);
        /// </code>
        /// </example>
        void AddError(ErrorNodeImpl e)
        {
            _diagnostics.AddError(e.Symbol.ToLocation(Filename ?? string.Empty), e.Symbol.Text,
                    $"Failed to parse script at position {e.Symbol.StartIndex}, line {e.Symbol.Line}, col {e.Symbol.Column} '{e.Symbol.Text}'"
            );
        }

        /// <summary>
        /// The initial source text of the policy being parsed.
        /// </summary>
        /// <remarks>
        /// This field stores the original source text for reference and error reporting.
        /// </remarks>
        private StringBuilder? _initialSource;

        /// <summary>
        /// The policy parser that generated the parse tree.
        /// </summary>
        /// <remarks>
        /// This field stores a reference to the parser for accessing token information and parse context.
        /// </remarks>
        private readonly PolicyParser _parser;

        /// <summary>
        /// Container for diagnostic messages generated during parsing.
        /// </summary>
        /// <remarks>
        /// This field stores errors, warnings, and informational messages that occur during parsing.
        /// </remarks>
        private ScriptDiagnostics _diagnostics;

        /// <summary>
        /// The file path of the policy script being parsed.
        /// </summary>
        /// <remarks>
        /// This field stores the full path to the script file for error reporting and diagnostics.
        /// </remarks>
        private readonly string _scriptPath;

        /// <summary>
        /// The container to which parsed policies are added.
        /// </summary>
        /// <remarks>
        /// This field stores the container that will hold all the parsed policy variables and rules.
        /// </remarks>
        private PolicyContainer? _container;

        /// <summary>
        /// Action to execute on each parsed policy rule.
        /// </summary>
        /// <remarks>
        /// This field stores a callback that is invoked for each successfully parsed policy rule.
        /// </remarks>
        private readonly Action<PolicyRule>? _action;

        /// <summary>
        /// The directory containing the policy script being parsed.
        /// </summary>
        /// <remarks>
        /// This field stores the directory path, which is used for resolving relative imports.
        /// </remarks>
        private readonly string _scriptPathDirectory;

        /// <summary>
        /// The culture used for parsing culture-specific values.
        /// </summary>
        /// <remarks>
        /// This field stores the culture settings used for parsing numbers, dates, and other culture-specific values.
        /// </remarks>
        private CultureInfo _currentCulture;

    }

}


